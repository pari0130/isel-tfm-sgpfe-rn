
CREATE DATABASE "FEI";

DROP DATABASE IF EXISTS "FEI"
CREATE DATABASE "FEI";

-- triggers to insert and update the client_ticket and attended_ticket
DROP TABLE IF EXISTS SERVICE;
CREATE TABLE IF NOT EXISTS SERVICE (
	id SERIAL PRIMARY KEY,
	name VARCHAR(50) NOT NULL,
	description VARCHAR(200) NOT NULL,
	state BIT NOT NULL DEFAULT 1::BIT
);

DROP TABLE IF EXISTS SERVICE_POSTOFFICE CASCADE;
CREATE TABLE IF NOT EXISTS SERVICE_POSTOFFICE (
	id SERIAL PRIMARY KEY,
	latitude DECIMAL NOT NULL,
	longitude DECIMAL NOT NULL,
	description VARCHAR(200) NOT NULL,
	serviceId INT NOT NULL REFERENCES SERVICE (id),
	address VARCHAR(200) NOT NULL,
	state BIT NOT NULL DEFAULT 1::BIT
);

DROP TABLE IF EXISTS QUEUE_TYPE;
CREATE TABLE IF NOT EXISTS QUEUE_TYPE (
	id SERIAL PRIMARY KEY,
	description VARCHAR(50),
	state BIT NOT NULL DEFAULT 1::BIT
);

DROP TABLE IF EXISTS QUEUE;
CREATE TABLE IF NOT EXISTS QUEUE (
	id SERIAL PRIMARY KEY,
	activeServers INT NOT NULL,
	letter VARCHAR(3) NOT NULL,
	name VARCHAR(20) NOT NULL,		
	description VARCHAR(200) NOT NULL, -- ticket description
	type INT NOT NULL REFERENCES QUEUE_TYPE (id), -- ticket type. eg NORMAL URGENT ..
	maxAvailable INT NOT NULL,           
	servicePostOfficeId INT NOT NULL REFERENCES SERVICE_POSTOFFICE (id),
	tolerance BOOLEAN NOT NULL,
	state BIT NOT NULL DEFAULT 1::BIT
);

DROP TABLE IF EXISTS QUEUE_STATE;
CREATE TABLE IF NOT EXISTS QUEUE_STATE (
	id SERIAL PRIMARY KEY,
	number INT NOT NULL,
	letter VARCHAR(3) NOT NULL,
	queueId INT NOT NULL REFERENCES QUEUE(id)		
);

DROP TABLE IF EXISTS QUEUE_ATTENDED;
CREATE TABLE IF NOT EXISTS QUEUE_ATTENDED (
	id SERIAL PRIMARY KEY,
	number INT NOT NULL,
	letter VARCHAR(3) NOT NULL,
	queueId INT NOT NULL REFERENCES QUEUE(id)	
);

DROP TABLE IF EXISTS FEI_USER CASCADE;
CREATE TABLE IF NOT EXISTS FEI_USER (
	id SERIAL NOT NULL PRIMARY KEY,
	username VARCHAR(25) NOT NULL UNIQUE,
	name VARCHAR(100) NOT NULL,
	nif INT NOT NULL CHECK (nif > 100000000 and nif < 999999999),
	password VARCHAR(150) NOT NULL,
	salt VARCHAR(150) NOT NULL,
	fcm_token VARCHAR(200),
	phone INT NOT NULL CHECK (phone > 100000000 and phone < 999999999),
	address VARCHAR(250), -- for now this can be null
	email VARCHAR(100) NOT NULL UNIQUE,
	state BIT NOT NULL DEFAULT 1::BIT
);

DROP TABLE IF EXISTS TICKET_USER;
CREATE TABLE IF NOT EXISTS TICKET_USER (
	id SERIAL PRIMARY KEY,
	queueId INT NOT NULL REFERENCES QUEUE(id),
	number INT NOT NULL,
	userId INT NOT NULL REFERENCES FEI_USER(id),
	createdAt TIMESTAMP NOT NULL DEFAULT NOW(),
	attended BIT NOT NULL DEFAULT 0::BIT,
	duration DOUBLE PRECISION DEFAULT 0.0,
	state BIT NOT NULL DEFAULT 1::BIT,
	canceled BIT NOT NULL DEFAULT 0::BIT,
	forecast DOUBLE PRECISION NOT NULL DEFAULT 0.0,
	updatedAt TIMESTAMP NOT NULL DEFAULT NOW()
);

DROP TABLE IF EXISTS SESSION;
CREATE TABLE IF NOT EXISTS SESSION (
	id SERIAL PRIMARY KEY,
	userId INT NOT NULL REFERENCES FEI_USER(id),
	token VARCHAR(100),
	createdAt TIMESTAMP NOT NULL DEFAULT NOW()
);

DROP TABLE IF EXISTS FORECAST;
CREATE TABLE IF NOT EXISTS FORECAST (
	id SERIAL PRIMARY KEY,
	queueId INT NOT NULL REFERENCES QUEUE(id),
	alpha DOUBLE PRECISION NOT NULL DEFAULT 0.2,
	flimit INT NOT NULL DEFAULT 10,
	forecast DOUBLE PRECISION DEFAULT 0.0 --last day of the week forecast?
);

DROP TABLE IF EXISTS ROLES;
CREATE TABLE ROLES
(
	id SERIAL PRIMARY KEY,
	role VARCHAR UNIQUE NOT NULL
);

DROP TABLE IF EXISTS USER_ROLE;
CREATE TABLE USER_ROLE
(
	userId INTEGER NOT NULL REFERENCES FEI_USER(id) PRIMARY KEY,
	role VARCHAR NOT NULL REFERENCES ROLES(role)
);

-- todo maybe add createdAt column
DROP TABLE IF EXISTS QUEUE_OBSERVERS;
CREATE TABLE IF NOT EXISTS QUEUE_OBSERVERS (
	id SERIAL PRIMARY KEY,
	queueId INTEGER NOT NULL REFERENCES QUEUE(id),
	userId INTEGER NOT NULL REFERENCES FEI_USER(id)
);

-- todo maybe add createdAt column
DROP TABLE IF EXISTS POST_OFFICE_OBSERVERS;
CREATE TABLE IF NOT EXISTS POST_OFFICE_OBSERVERS (
	id SERIAL PRIMARY KEY,
	userId INTEGER NOT NULL REFERENCES FEI_USER(id),
	postId INTEGER NOT NULL REFERENCES SERVICE_POSTOFFICE(id)
);

DROP TABLE IF EXISTS LOCATION;
CREATE TABLE IF NOT EXISTS LOCATION (
	id SERIAL PRIMARY KEY,
	latitude DOUBLE PRECISION NOT NULL,
	longitude DOUBLE PRECISION NOT NULL,
	updatedAt TIMESTAMP DEFAULT NOW(), 
	userId INTEGER references FEI_USER(id)
);

DROP FUNCTION IF EXISTS GET_NEXT_IN_LINE;
CREATE FUNCTION GET_NEXT_IN_LINE (ticket_id INT, ticket_number INT)
RETURNS TEXT AS $$
	SELECT FU.fcm_token from FEI_USER AS FU 
	INNER JOIN TICKET_USER AS TU ON FU.id = TU.id 
	WHERE TU.id = ticket_id and TU.number = ticket_number + 1 and createdAt > NOW()::DATE and attended = 0::BIT; 
$$
LANGUAGE sql;

CREATE OR REPLACE PROCEDURE SET_USER_TICKET_ATTENDED(
   queue_id INT,
   t_number INT 
)
LANGUAGE SQL    
AS $$
	UPDATE TICKET_USER SET duration = (EXTRACT(EPOCH FROM NOW()::timestamp - updatedAt::timestamp)/60), attended = 1::BIT WHERE queueId = queue_id AND number = t_number AND attended = 0::BIT;
	UPDATE TICKET_USER SET updatedAt = NOW()::timestamp WHERE number = t_number + 1 AND queueId = queue_id AND attended = 0::BIT;
$$


DROP FUNCTION IF EXISTS CREATE_QUEUE_TABLES;
CREATE FUNCTION CREATE_QUEUE_TABLES()
returns TRIGGER
AS $$
	BEGIN
		INSERT INTO QUEUE_STATE (number, letter, queueId) VALUES (1, NEW.letter, NEW.id);
		INSERT INTO QUEUE_ATTENDED (number, letter, queueId) VALUES (1, NEW.letter, NEW.id);
		return NULL;
	END;
$$
LANGUAGE plpgsql;


DROP FUNCTION IF EXISTS UPDATE_QUEUE_TABLES;
CREATE FUNCTION UPDATE_QUEUE_TABLES()
returns TRIGGER
AS $$
	BEGIN	
		UPDATE QUEUE_STATE SET letter = NEW.letter WHERE queueId = NEW.id; 
		UPDATE QUEUE_ATTENDED SET letter = NEW.letter WHERE queueId = NEW.id; 
		return NULL;
	END;
$$
LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS create_queue_state_and_attended;
CREATE TRIGGER create_queue_state_and_attended 
	AFTER INSERT ON QUEUE
	FOR EACH ROW 
	EXECUTE PROCEDURE CREATE_QUEUE_TABLES();

DROP TRIGGER IF EXISTS update_queue_state_and_attended;
CREATE TRIGGER update_queue_state_and_attended 
	AFTER UPDATE ON QUEUE
	FOR EACH ROW 
	WHEN (OLD.letter IS DISTINCT FROM NEW.letter)
	EXECUTE PROCEDURE UPDATE_QUEUE_TABLES();

DROP FUNCTION IF EXISTS CREATE_USER_LOCATION;
CREATE FUNCTION CREATE_USER_LOCATION()
returns TRIGGER
AS $$
	BEGIN
		INSERT INTO LOCATION (latitude, longitude, userId) VALUES (0.0, 0.0, NEW.id);
		return NULL;
	END;
$$
LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS create_user_trigger;
CREATE TRIGGER create_user_trigger 
	AFTER INSERT ON FEI_USER
	FOR EACH ROW 
	EXECUTE PROCEDURE CREATE_USER_LOCATION();


DROP TABLE IF EXISTS USER_SERVICE;
CREATE TABLE USER_SERVICE
(
	userId INTEGER NOT NULL REFERENCES FEI_USER(id) PRIMARY KEY,
	serviceId INTEGER NOT NULL REFERENCES SERVICE(id)
);


DROP TABLE IF EXISTS USER_POST_OFFICE;
CREATE TABLE USER_POST_OFFICE
(
	userId INTEGER NOT NULL REFERENCES FEI_USER(id) PRIMARY KEY,
	servicePostOfficeId INTEGER NOT NULL REFERENCES SERVICE_POSTOFFICE(id)
);

DROP TABLE IF EXISTS PATH_CONTROL_ACCESS;
CREATE TABLE PATH_CONTROL_ACCESS
(
	id SERIAL PRIMARY KEY,
	method VARCHAR CHECK (method = 'GET' or method = 'PUT' or method = 'POST' or method = 'DELETE'),
	regex VARCHAR NOT NULL,
	roles VARCHAR NOT NULL
);

